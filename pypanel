#!/usr/bin/python -OO

# vim: set ts=4 sw=4 expandtab:

"""
PyPanel v2.4 - Lightweight panel/taskbar for X11 window managers
Copyright (c) 2003-2005 Jon Gelo (ziljian@users.sourceforge.net)

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
"""
#----------------------------------------------------------------------------
class Obj(object):
#----------------------------------------------------------------------------
    """ Multi-purpose class """
    #----------------------------
    def __init__(self, **kwargs):
    #----------------------------
        self.__dict__.update(kwargs)

#----------------------------------------------------------------------------
class HorizontalLayout(object):
#----------------------------------------------------------------------------

    x = 0
    y = 0
    rowicons = 1

    #--------------------------
    def __init__(self, screen):
    #--------------------------

        global P_LOCATION, P_THICKNESS, P_START, P_LENGTH

        if P_LOCATION == 0:
            self.posy = 0
        else:
            self.posy = screen.height_in_pixels - P_THICKNESS

        if P_LENGTH == 0:
            P_LENGTH = screen.width_in_pixels

        self.posx = P_START

        self.width = P_LENGTH
        self.height = P_THICKNESS

    #---------------------
    def incPos(self, inc):
    #---------------------

        self.x += inc

    #------------------------------------------------
    def getIcon(self, winid, task, x, y, launcher=0):
    #------------------------------------------------

        if not launcher and not APPICONS:
            return 0

        y = (P_THICKNESS-I_SIZE)/2
        w = I_SIZE
        h = I_SIZE

        if launcher:
            name = task.app
        else:
            name = task.tclass

        icon = task.icon
        rc = ppicon(winid, icon.pixmap, icon.mask, x, y, icon.width, icon.height, w, h, icon.data, icon.path)

        if not rc:
            self.clearPanel(x, 0, w, P_THICKNESS)
            sys.stderr.write("Failed to get icon for '%s'\n%s\n\n" % (name, icon.path))

        return 1

    #-----------------------------------
    def getTaskEndPosition(self, space):
    #-----------------------------------

        return [
            self.x + space,
            self.y
        ]

    #-----------------------
    def incToNextTask(self):
    #-----------------------

        self.x += P_SPACER / 2

    #---------------------------------------
    def incToNextTrayIcon(self, count, max):
    #---------------------------------------

        self.x += I_SIZE

    #------------------------------------------
    def getTaskTextLimit(self, visible, space):
    #------------------------------------------

        limit = space/float(len(visible)) - P_SPACER*2
        if not T_FILL:
            # if not fill, set task width to min(limit, t_width)
            templimit = T_WIDTH - P_SPACER * 2
            if templimit < limit:
                limit = templimit;

        # if show icons, subtract that from task width too (+ spacer)
        if APPICONS:
            limit -= I_SIZE + P_SPACER

        if limit < 1:
            limit = 1

        return limit

    #------------------------------------------
    def drawClockDesktopText(self, panel, obj):
    #------------------------------------------

        panel.drawText(obj, obj.x1, obj.y1, obj.width)

    #----------------------------
    def drawLine(self, win, lgc):
    #----------------------------

        if SHOWLINES:
            x = self.x - P_SPACER / 2
            win.poly_segment(lgc, [(x, self.y, x, self.y + P_THICKNESS)])

    #--------------------------
    def expand(self, pnl, win):
    #--------------------------

        return 0

    #--------------------------
    def shrink(self, pnl, win):
    #--------------------------

        return 0

#----------------------------------------------------------------------------
class VerticalLayout(object):
#----------------------------------------------------------------------------

    x = 0
    y = 0
    rowicons = 0
    expandstate = 0

    #--------------------------
    def __init__(self, screen):
    #--------------------------

        global P_LOCATION, P_THICKNESS, P_START, P_LENGTH

        if P_LOCATION == 2:
            self.posx = 0
        else:
            self.posx = screen.width_in_pixels - P_THICKNESS

        if P_LENGTH == 0:
            P_LENGTH = screen.height_in_pixels

        # determine amount of icons per row for launcher & tray
        self.rowicons = P_THICKNESS / I_SIZE

        self.posy = P_START

        self.width = P_THICKNESS
        self.height = P_LENGTH

    #---------------------
    def incPos(self, inc):
    #---------------------

        self.x = 0
        self.y += inc

    #------------------------------------------------
    def getIcon(self, winid, task, x, y, launcher=0):
    #------------------------------------------------

        if not launcher and not APPICONS:
            return 0

        w = I_SIZE
        h = I_SIZE

        if launcher:
            name = task.app
        else:
            name = task.tclass

        icon = task.icon
        rc = ppicon(winid, icon.pixmap, icon.mask, x, y, icon.width, icon.height, w, h, icon.data, icon.path)
        if not rc:
            self.clearPanel(x, y, w, h)
            sys.stderr.write("Failed to get icon for '%s'\n%s\n\n" % (name, icon.path))

        return 1

    #-----------------------------------
    def getTaskEndPosition(self, space):
    #-----------------------------------

        return [
            self.x,
            self.y + space
        ]

    #-----------------------
    def incToNextTask(self):
    #-----------------------

        self.x = 0
        self.y += I_SIZE

    #---------------------------------------
    def incToNextTrayIcon(self, count, max):
    #---------------------------------------

        if count % self.rowicons != 0 and count != max:
            self.x += I_SIZE
            return
        self.incToNextTask()

    #------------------------------------------
    def getTaskTextLimit(self, visible, space):
    #------------------------------------------

        limit = self.width

        # if show icons, subtract that from task width too (+ spacer)
        if APPICONS:
            limit -= I_SIZE + P_SPACER

        if limit < 1:
            limit = 1

        return limit

    #------------------------------------------
    def drawClockDesktopText(self, panel, obj):
    #------------------------------------------

        if obj.width < self.width:
            # nicely in the middle of the bar if vertical (and enough space)
            x = (self.width - obj.width) / 2
            panel.drawText(obj, x, obj.y1, obj.width)

    #----------------------------
    def drawLine(self, win, lgc):
    #----------------------------

        if SHOWLINES:
            y = self.y - P_SPACER / 2
            win.poly_segment(lgc, [(self.x, y, self.x + self.width, y)])

    #--------------------------
    def expand(self, pnl, win):
    #--------------------------

        if self.expandstate:
            return 0

        self.expandstate = 1

        self.width = P_EXPAND
        if P_LOCATION == 3:
            self.posx += P_THICKNESS - P_EXPAND

        pnl.setStruts(win, state=2)
        return 1

    #--------------------------
    def shrink(self, pnl, win):
    #--------------------------

        if not self.expandstate:
            return 0

        self.expandstate = 0

        self.width = P_THICKNESS
        if P_LOCATION == 3:
            self.posx += P_EXPAND - P_THICKNESS

        pnl.setStruts(win, state=0)
        return 1

#----------------------------------------------------------------------------
class PyPanel(object):
#----------------------------------------------------------------------------
    #---------------------------
    def __init__(self, display):
    #---------------------------
        """ Initialize and display the panel """
        self.display = display                   # Display obj
        self.screen  = display.screen()          # Screen obj
        self.root    = self.screen.root          # Display root
        self.error   = error.CatchError()        # Error Handler/Suppressor
        self.panel   = {"sections":[]}           # Panel data and layout
        self.colors  = {}                        # Alloc'd colors
        self.hidden  = 0                         # Panel hidden/minimized
        self.focus   = 0                         # Currently focused window
        self.rpm     = None                      # Root pixmap ID
        self.beats   = bool(TIME_BEATS)
        self.lgc     = None

        global P_LOCATION, P_THICKNESS

        # Misc. initializations
        if SHOWLINES or SHOWBORDER:
            self.lgc = self.root.create_gc(foreground=self.getColor(LINE_COLOR))
        if SHOWBORDER:
            P_THICKNESS += 2

        if P_LOCATION < 2:
            self.location = HorizontalLayout(self.screen)
        else:
            self.location = VerticalLayout(self.screen)

        # Setup the panel's window
        self.window = self.screen.root.create_window(
            self.location.posx,
            self.location.posy,
            self.location.width,
            self.location.height,
            0,
            self.screen.root_depth,
            window_class=X.InputOutput,
            visual=X.CopyFromParent,
            colormap=X.CopyFromParent,
            event_mask=(X.ExposureMask|X.ButtonPressMask|X.ButtonReleaseMask|X.EnterWindowMask|X.LeaveWindowMask)
        )
        ppinit(self.window.id, FONT)

        # Init the panel sections
        if DESKTOP:
            self.panel["sections"].append(DESKTOP)
            self.panel[DESKTOP] = Obj(id="desktop", names=[], first=0, last=0)
        if CLOCK:
            self.panel["sections"].append(CLOCK)
            self.panel[CLOCK] = Obj(id="clock", name="", first=0, last=0, x1=0, x2=0, y1=0, y2=0, color=self.getColor(CLOCK_COLOR), shadow=self.getColor(CLOCK_SHADOW_COLOR), width=-1)
        if TRAY:
            self.panel["sections"].append(TRAY)
            self.panel[TRAY] = Obj(id="tray", tasks={}, order=[], first=0, last=0, window=self.window)
            self.createTray(self.display, self.screen)
        if LAUNCHER and LAUNCH_LIST:
            self.panel["sections"].append(LAUNCHER)
            self.panel[LAUNCHER] = Obj(id="launcher", tasks={}, order=[], first=0, last=0)
            self.createLauncher()

        self.panel["sections"].append(TASKS)
        self.panel[TASKS] = Obj(id="tasks", tasks={}, order=[], first=0, last=0)
        self.panel["sections"].sort()
        self.panel[self.panel["sections"][0]].first = 1
        self.panel[self.panel["sections"][-1]].last = 1

        # Init the properties and then start the event loop
        self.struts = {
            'top'         : 0,
            'top_start'   : 0,
            'top_end'     : 0,
            'bottom'      : 0,
            'bottom_start': 0,
            'bottom_end'  : 0,
            'left'        : 0,
            'left_start'  : 0,
            'left_end'    : 0,
            'right'       : 0,
            'right_start' : 0,
            'right_end'   : 0
        }
        self.setProps(self.display, self.window)
        self.setStruts(self.window);
        self.getDesktopNames()
        self.root.change_attributes(event_mask=(X.PropertyChangeMask))
        self.window.map()
        self.display.flush()
        self.loop(self.display, self.root, self.window, self.panel)

    #------------------------------------
    def clearPanel(self, x, y, w, h):
    #------------------------------------
        """ Clear panel at the given coordinates """
        ppclear(self.window.id, int(x), y, int(w), h)
        if SHOWBORDER:
            self.window.rectangle(self.lgc, 0, 0, self.location.width-1, self.location.height-1)

    #------------------------
    def createLauncher(self):
    #------------------------
        """ Initialize the Application Launcher """
        order = []
        tasks = {}
        for app, icon in LAUNCH_LIST:
            order.append(app)
            iobj = Obj(path=icon, data="", width=0, height=0, pixmap=0, mask=0)
            tasks[app] = Obj(x1=0, x2=0, y1=0, y2=0, app=app+" &", icon=iobj)
            self.panel[LAUNCHER].tasks = tasks
            self.panel[LAUNCHER].order = order

    #------------------------------
    def createTray(self, dsp, scr):
    #------------------------------
        """ Create the System Tray Selection Owner Window """
        self._OPCODE = dsp.intern_atom("_NET_SYSTEM_TRAY_OPCODE")
        manager      = dsp.intern_atom("MANAGER")
        selection    = dsp.intern_atom("_NET_SYSTEM_TRAY_S%d" % dsp.get_default_screen())

        # Selection owner window
        self.selowin = scr.root.create_window(-1, -1, 1, 1, 0, self.screen.root_depth)
        self.selowin.set_selection_owner(selection, X.CurrentTime)
        self.sendEvent(self.root, manager,[X.CurrentTime, selection, self.selowin.id], (X.StructureNotifyMask))

    #------------------------------------
    def drawText(self, obj, x, y, width):
    #------------------------------------
        """ Draw the given objects name at x """

        width += 2 # prevents cutting of last char

        if width < 1:
            # prevents infinite loop
            return 0

        if T_FORCE_ASCII == 0:
            title = obj.name.encode('utf-8')
        else:
            title = obj.name.encode('ascii', 'ignore')

        if SHADOWS:
            ppfont(self.window.id, obj.shadow, x+1, y+1, I_SIZE+2, width, title)
        ppfont(self.window.id, obj.color, x, y, I_SIZE, width, title)

    #----------------------------
    def setProps(self, dsp, win):
    #----------------------------
        """ Set necessary X atoms and panel window properties """
        self._ABOVE           = dsp.intern_atom("_NET_WM_STATE_ABOVE")
        self._BELOW           = dsp.intern_atom("_NET_WM_STATE_BELOW")
        self._BLACKBOX        = dsp.intern_atom("_BLACKBOX_ATTRIBUTES")
        self._CHANGE_STATE    = dsp.intern_atom("WM_CHANGE_STATE")
        self._CLIENT_LIST     = dsp.intern_atom("_NET_CLIENT_LIST")
        self._CURRENT_DESKTOP = dsp.intern_atom("_NET_CURRENT_DESKTOP")
        self._DESKTOP         = dsp.intern_atom("_NET_WM_DESKTOP")
        self._DESKTOP_COUNT   = dsp.intern_atom("_NET_NUMBER_OF_DESKTOPS")
        self._DESKTOP_NAMES   = dsp.intern_atom("_NET_DESKTOP_NAMES")
        self._HIDDEN          = dsp.intern_atom("_NET_WM_STATE_HIDDEN")
        self._ICON            = dsp.intern_atom("_NET_WM_ICON")
        self._NAME            = dsp.intern_atom("_NET_WM_NAME")
        self._RPM             = dsp.intern_atom("_XROOTPMAP_ID")
        self._SHADED          = dsp.intern_atom("_NET_WM_STATE_SHADED")
        self._SHOWING_DESKTOP = dsp.intern_atom("_NET_SHOWING_DESKTOP")
        self._SKIP_PAGER      = dsp.intern_atom("_NET_WM_STATE_SKIP_PAGER")
        self._SKIP_TASKBAR    = dsp.intern_atom("_NET_WM_STATE_SKIP_TASKBAR")
        self._STATE           = dsp.intern_atom("_NET_WM_STATE")
        self._STICKY          = dsp.intern_atom("_NET_WM_STATE_STICKY")
        self._STRUT           = dsp.intern_atom("_NET_WM_STRUT")
        self._STRUTP          = dsp.intern_atom("_NET_WM_STRUT_PARTIAL")
        self._WMSTATE         = dsp.intern_atom("WM_STATE")

        win.set_wm_name("PyPanel")
        win.set_wm_class("pypanel","PyPanel")
        win.set_wm_hints(
            flags=(
                Xutil.InputHint|Xutil.StateHint
            ),
            input=0,
            initial_state=1
        )
        win.set_wm_normal_hints(
            flags=(
                Xutil.PPosition|Xutil.PMaxSize|Xutil.PMinSize
            ),
            min_width=self.location.width,
            min_height=self.location.height,
            max_width=self.location.width,
            max_height=self.location.height
        )
        win.change_property(dsp.intern_atom("_WIN_STATE"),Xatom.CARDINAL,32,[1])
        win.change_property(dsp.intern_atom("_MOTIF_WM_HINTS"),
            dsp.intern_atom("_MOTIF_WM_HINTS"), 32, [0x2, 0x0, 0x0, 0x0, 0x0])
        win.change_property(self._DESKTOP, Xatom.CARDINAL, 32, [0xffffffffL])
        win.change_property(dsp.intern_atom("_NET_WM_WINDOW_TYPE"),
            Xatom.ATOM, 32, [dsp.intern_atom("_NET_WM_WINDOW_TYPE_DOCK")])

    #----------------------------------
    def setStruts(self, win, state=0):
    #----------------------------------

        strutloc = ['top', 'bottom', 'left', 'right'][P_LOCATION]

        self.struts[strutloc           ] = P_THICKNESS
        self.struts[strutloc + '_start'] = P_START
        self.struts[strutloc + '_end'  ] = P_START + P_LENGTH

        if state == 1:
            self.struts[strutloc] = HIDDEN_SIZE
        if state == 2:
            self.struts[strutloc] = P_EXPAND

        win.change_property(self._STRUT, Xatom.CARDINAL, 32, [
            self.struts['left'],
            self.struts['right'],
            self.struts['top'],
            self.struts['bottom']
        ])

        win.change_property(self._STRUTP, Xatom.CARDINAL, 32, [
            self.struts['left'],
            self.struts['right'],
            self.struts['top'],
            self.struts['bottom'],
            self.struts['left_start'],
            self.struts['left_end'],
            self.struts['right_start'],
            self.struts['right_end'],
            self.struts['top_start'],
            self.struts['top_end'],
            self.struts['bottom_start'],
            self.struts['bottom_end']
        ])

    #-----------------------------------------
    def setState(self, task, panel, win=None):
    #-----------------------------------------
        """ Set/Update a tasks state.  Returns -
            0 - no panel update needed
            1 - panel update needed
        """
        task.state   = []

        try:
            task.state = task.obj.get_full_property(self._STATE, Xatom.ATOM).value
        except:
            pass
        try:
            wmstate = task.obj.get_full_property(self._WMSTATE, 0).value
            if wmstate and (wmstate[0] == Xutil.IconicState):
                task.state.insert(0, self._HIDDEN)
        except:
            if self.taskDelete(task.id, panel):
                return 1

        # set color based on state
        if task.id == self.focus:
            task.color = self.getColor(FOCUSED_COLOR)
            task.shadow = self.getColor(FOCUSED_SHADOW_COLOR)
        elif self._SHADED in task.state:
            task.color = self.getColor(SHADED_COLOR)
            task.shadow = self.getColor(SHADED_SHADOW_COLOR)
        elif self._HIDDEN in task.state:
            task.color = self.getColor(MINIMIZED_COLOR)
            task.shadow = self.getColor(MINIMIZED_SHADOW_COLOR)
        else:
            task.color = self.getColor(TASK_COLOR)
            task.shadow = self.getColor(TASK_SHADOW_COLOR)

        if SHOWMINIMIZED:
            if (self._HIDDEN not in task.state and task.visible) or\
               (self._HIDDEN in task.state and not task.visible):
                return 1

        if win and task.visible:
            x = task.x1
            if APPICONS:
                x += I_SIZE + P_SPACER
            self.clearPanel(x, task.y1, task.x2-x, task.y2 - task.y1)
            self.drawText(task, x, task.y1, task.x2 - x)

        return 0

    #----------------------------
    def setName(self, win, task):
    #----------------------------
        """ Set/update the name of the given task """
        name = self.getName(task.obj)
        if task.name != name:
            task.name = name
            if task.visible:
                x = task.x1
                if APPICONS:
                    x += I_SIZE + P_SPACER
                self.clearPanel(x, task.y1, task.x2 - x, task.y2 - task.y1)
                self.drawText(task, x, task.y1, task.x2 - x)

    #-----------------------
    def setIcon(self, task):
    #-----------------------
        """ Create an icon object for the given task """
        if not APPICONS:
            return

        icon = Obj(path="", data="", width=0, height=0, pixmap=0L, mask=0L)

        for tc in task.tclass:
            if tc in ICON_LIST:
                icon.path = ICON_LIST[tc]
                task.icon = icon
                return
        try:
            # _net_wm_icon
            data = task.obj.get_full_property(self._ICON, 0)
            if data:
                data        = data.value[:]
                icon.width  = data[0]
                icon.height = data[1]
                icon.data   = data[2:data[0]*data[1]+2].tostring()
            else:
                # wmhints icon
                hints       = task.obj.get_wm_hints()
                geom        = hints.icon_pixmap.get_geometry()
                icon.pixmap = hints.icon_pixmap.id
                icon.mask   = hints.icon_mask.id
                icon.width  = geom.width
                icon.height = geom.height

                if icon.mask > sys.maxint:
                    icon.mask = 0
                if icon.pixmap > sys.maxint:
                    raise
        except:
            # default icon
            icon.path = ICON_LIST["default"] or "%s/pypanel/ppicon.png" % sysconfig.get_python_lib()

        task.icon = icon

    #-------------------------
    def getDesktopNames(self):
    #-------------------------
        """ Populate the desktop obj with the names of each desktop """
        if not DESKTOP:
            return

        if SHADOWS:
            shadow = self.getColor(DESKTOP_SHADOW_COLOR)
        else:
            shadow = None

        color         = self.getColor(DESKTOP_COLOR)
        desktop       = self.panel[DESKTOP]
        desktop.names = []
        desktop.total = self.root.get_full_property(self._DESKTOP_COUNT, 0).value[0]

        if DESKTOP_NAMES:
            names = DESKTOP_NAMES
        else:
            names = self.root.get_full_property(self._DESKTOP_NAMES, 0)
            if hasattr(names, "value"):
                names = names.value.split("\x00")
            else:
                names = []
                for x in range(desktop.total):
                    names.append(str(x))

        if len(names) < desktop.total:
            for x in range(len(names), desktop.total):
                names.append(str(x))

        for name in names:
            obj = Obj(name=name, width=ppfontsize(name), color=color, shadow=shadow)
            desktop.names.append(obj)

    #-------------------------------
    def getDesktop(self, task=None):
    #-------------------------------
        """ Return the desktop number of the given task obj """
        if task is None:
            return self.root.get_full_property(self._CURRENT_DESKTOP, Xatom.CARDINAL).value[0]

        try:
            return task.get_full_property(self._DESKTOP, Xatom.CARDINAL).value[0]
        except:
            try:
                return task.get_full_property(self._BLACKBOX, 0).value[2]
            except:
                return None

    #-------------------------
    def getColor(self, color):
    #-------------------------
        """ Function to get/convert/alloc a color given a single hex str """
        if color in self.colors:
            return self.colors[color]
        else:
            r = int("0x"+color[2:4],0)*257
            g = int("0x"+color[4:6],0)*257
            b = int("0x"+color[6:8],0)*257
            c = self.screen.default_colormap.alloc_color(r, g, b)

            if not c:
                sys.stderr.write("Error allocating color: %s\n" % color)
                return self.screen.white_pixel
            else:
                self.colors[color] = c.pixel
                return c.pixel

    #-----------------------
    def getName(self, task):
    #-----------------------
        """ Return the name of the given task obj """
        try:
            name = task.get_full_property(self._NAME, 0) or task.get_full_property(Xatom.WM_NAME, 0)
            return name.value.decode('utf-8')
        except:
            return ""

    #------------------------------------------------
    def sendEvent(self, win, ctype, data, mask=None):
    #------------------------------------------------
        """ Send a ClientMessage event to the root """
        data = (data+[0]*(5-len(data)))[:5]
        ev = Xlib.protocol.event.ClientMessage(window=win, client_type=ctype, data=(32,(data)))

        if not mask:
            mask = (X.SubstructureRedirectMask|X.SubstructureNotifyMask)
        self.root.send_event(ev, event_mask=mask)

    #----------------------------
    def changeDesktop(self, num):
    #----------------------------
        """ Increase/Decrease the current desktop number by num """
        cur = self.getDesktop() + num

        if cur < 0:
            cur = self.panel[DESKTOP].total - 1
        elif cur == self.panel[DESKTOP].total:
            cur = 0

        self.sendEvent(self.root, self._CURRENT_DESKTOP, [cur])

    #---------------------
    def showDesktop(self):
    #---------------------
        """ Toggle between hiding and unhiding ALL applications """
        showing = self.root.get_full_property(self._SHOWING_DESKTOP, 0)

        if hasattr(showing, "value"):
            if showing.value[0] == 0:
                self.sendEvent(self.root, self._SHOWING_DESKTOP, [1])
            else:
                self.sendEvent(self.root, self._SHOWING_DESKTOP, [0])

    #----------------------
    def toggleHidden(self):
    #----------------------
        """ Hide/Unhide the Panel """
        if self.hidden:
            self.window.configure(x=self.location.posx, y=self.location.posy, width=self.location.width, height=self.location.height)
            self.setStruts(self.window, state=0)
            if ABOVE:
                self.sendEvent(self.window, self._STATE, [0, self._BELOW])
                self.sendEvent(self.window, self._STATE, [1, self._ABOVE])
            else:
                self.sendEvent(self.window, self._STATE, [1, self._BELOW])
                self.sendEvent(self.window, self._STATE, [0, self._ABOVE])
        else:
            x = self.location.posx
            y = self.location.posy
            width = self.location.width
            height = self.location.height
            if P_LOCATION == 0:
                y = 0
                height = HIDDEN_SIZE
            elif P_LOCATION == 1:
                y += P_THICKNESS - HIDDEN_SIZE
                height = HIDDEN_SIZE
            elif P_LOCATION == 2:
                x = 0
                width = HIDDEN_SIZE
            elif P_LOCATION == 3:
                x += P_THICKNESS - HIDDEN_SIZE
                width = HIDDEN_SIZE

            self.window.configure(x=x, y=y, width=width, height=height)
            self.setStruts(self.window, state=1)

        self.hidden = not self.hidden

    #----------------------------------------
    def updateExpand(self, root, win, panel):
    #----------------------------------------

        win.set_wm_normal_hints(
            flags=(
                Xutil.PPosition|Xutil.PMaxSize|Xutil.PMinSize
            ),
            min_width=self.location.width,
            min_height=self.location.height,
            max_width=self.location.width,
            max_height=self.location.height
        )
        win.configure(width=self.location.width)
        # dirty sh#!, prevents flickering
        # if expand is large, position would be changed to x
        # but width has not been changed yet which means the
        # mouse is not hovering the panel atm and X fires a
        # leave event, which causes it to shrink again...
        # So change width first, wait a bit, and change x
        time.sleep(0.03)
        win.configure(x=self.location.posx)
        self.updatePanel(root, win, panel)
        self.sendEvent(win, self._STATE, [0, self._BELOW])
        self.sendEvent(win, self._STATE, [1, self._ABOVE])

    #----------------------------------------
    def toggleMinimize(self, task, traise=1):
    #----------------------------------------
        """ Iconify/Deiconify a task """
        self.sendEvent(task.obj, self._STATE, [2, self._HIDDEN])
        if self._HIDDEN in task.state:
            task.obj.map()
        else:
            self.sendEvent(task.obj, self._CHANGE_STATE, [Xutil.IconicState])
        if traise:
            self.taskRaise(task, 0)

    #---------------------------
    def toggleShade(self, task):
    #---------------------------
        """ Shade/Unshade a task """
        self.sendEvent(task.obj, self._STATE, [2, self._SHADED])

    #--------------------------------
    def taskDelete(self, tid, panel):
    #--------------------------------
        """ Delete the given task ID if it's in the tray/task list """
        for section in (TASKS, TRAY):
            if section and tid in panel[section].tasks:
                del panel[section].tasks[tid]
                panel[section].order.remove(tid)
                return 1
        return 0

    #-------------------------
    def taskFocus(self, task):
    #-------------------------
        """ Give focus to an unfocused task else toggle minimization """
        if task.id == self.focus or self._HIDDEN in task.state:
            self.toggleMinimize(task)
        else:
            self.taskRaise(task, 1)

    #----------------------------------
    def taskRaise(self, task, focus=0):
    #----------------------------------
        """ Raise a task """
        if self._HIDDEN not in task.state:
            task.obj.configure(stack_mode=X.Above)
            if focus:
                task.obj.set_input_focus(X.RevertToNone, X.CurrentTime)

    #----------------------------------
    def taskLower(self, task, focus=0):
    #----------------------------------
        """ Lower a task """
        if self._HIDDEN not in task.state:
            task.obj.configure(stack_mode=X.Below)
            if focus:
                task.obj.set_input_focus(X.RevertToNone, X.CurrentTime)

    #---------------------------------------
    def buttonRelease(self, root, panel, e):
    #---------------------------------------
        """ Button Release event handler """
        x = e.event_x
        y = e.event_y
        for section in panel["sections"]:
            if panel[section].id == "tray":
                continue
            elif panel[section].id == "desktop":
                if panel[section].x1 <= x and x <= panel[section].x2 and panel[section].y1 <= y and y <= panel[section].y2:
                    desktopButtonEvent(self, e.detail)
                    return
            elif panel[section].id == "clock":
                if panel[section].x1 <= x and x <= panel[section].x2 and panel[section].y1 <= y and y <= panel[section].y2:
                    clockButtonEvent(self, e.detail)
                    return
            elif panel[section].id == "launcher" and e.detail == 1:
                for a in panel[section].tasks.values():
                    if a.x1 <= x and x <= a.x2 and a.y1 <= y and y <= a.y2:
                        os.system(a.app)
                        return
            else:
                if not panel[TASKS].tasks:
                    try:
                        panelButtonEvent(self, e.detail)
                    except NameError, e:
                        sys.stderr.write("\n'panelButtonEvent()' is not defined in your pypanelrc.\n")
                        sys.stderr.write("A current pypanelrc example can be found here -\n")
                        sys.stderr.write("%s/pypanel/pypanelrc\n" % sysconfig.get_python_lib())
                else:
                    cdt = self.getDesktop()
                    for t in panel[TASKS].tasks.values():
                        if t.visible and t.x1 <= x and x <= t.x2 and t.y1 <= y and y <= t.y2:
                            cdt = self.getDesktop()
                            tdt = t.desk
                            if SHOWALL and cdt != tdt and tdt != 0xffffffffL:
                                if SHOWALL == 1:
                                    # Move task to current desktop
                                    self.sendEvent(t.obj, self._DESKTOP, [cdt])
                                elif SHOWALL == 2:
                                    # Switch to tasks desktop
                                    self.sendEvent(root, self._CURRENT_DESKTOP, [tdt])
                                t.obj.map()
                                t.obj.configure(stack_mode=X.Above)
                            else:
                                taskButtonEvent(self, e.detail, t)
                            return

    #-------------------------------------
    def updateBackground(self, root, win):
    #-------------------------------------
        """ Check and update the panel background if necessary """
        rpm = root.get_full_property(self._RPM, Xatom.PIXMAP)

        if hasattr(rpm, "value"):
            rpm = rpm.value[0]
        else:
            rpm = root.id

        if self.rpm != rpm:
            self.rpm = rpm
            r = int("0x"+BG_COLOR[2:4],0)
            g = int("0x"+BG_COLOR[4:6],0)
            b = int("0x"+BG_COLOR[6:8],0)
            ppshade(win.id, rpm, self.location.posx, self.location.posy, self.location.width, self.location.height, r, g, b, SHADE)

    #------------------------
    def getTimeInBeats(self):
    #------------------------

        def _cleanupBeats(rawBeats):
            if rawBeats > 1000:
                return rawBeats - 1000
            if rawBeats < 0:
                return rawBeats + 1000
            return rawBeats

        def _cleanBeatsCalculation(hour, minute, second):
            return BEATS_FORMAT % (_cleanupBeats(sum([
                hour * 3600,
                minute * 60,
                second,
                time.timezone
            ]) / 86.4))

        return _cleanBeatsCalculation(*time.localtime()[3:6])

    #----------------------
    def getClockData(self):
    #----------------------

        if self.beats:
            return self.getTimeInBeats()
        return time.strftime(CLOCK_FORMAT, time.localtime())

    #---------------------------------------
    def updatePanel(self, root, win, panel):
    #---------------------------------------
        """ Redraw the panel """
        location   = self.location
        tasks      = panel[TASKS].tasks     # all tasks
        visible    = []                     # visible tasks
        location.x = 0
        location.y = 0
        space      = P_LENGTH - P_SPACER    # space we have to display tasks
        cdt        = self.getDesktop()
        clock      = None
        desktop    = None
        tray       = None
        launcher   = None

        if P_LOCATION < 2:
            location.x = P_SPACER
        else:
            location.y = P_SPACER

        if CLOCK:
            clock = panel[CLOCK]
            clock.name  = self.getClockData()
            clock.width = ppfontsize(clock.name)

            if P_LOCATION < 2:
                space -= clock.width
            else:
                space -= I_SIZE
            space -= P_SPACER

        if DESKTOP:
            desktop = panel[DESKTOP]

            space -= P_SPACER
            if P_LOCATION < 2:
                space -= desktop.names[cdt].width
            else:
                space -= I_SIZE

        if LAUNCHER and panel[LAUNCHER].tasks:
            launcher = panel[LAUNCHER]
            space -= (len(launcher.order) + location.rowicons - 1) / location.rowicons * I_SIZE
            space -= P_SPACER

        if TRAY and panel[TRAY].tasks:
            tray = panel[TRAY]
            for t in panel[TRAY].tasks.values():
                t.width = I_SIZE
            space -= (len(panel[TRAY].tasks) + location.rowicons - 1) / location.rowicons * I_SIZE
            space -= P_SPACER

        if TASKS and tasks:
            for task in panel[TASKS].order:
                t = tasks[task]
                t.visible = 0
                if not t.hidden:
                    if SHOWALL or (t.desk == cdt or t.desk == 0xffffffffL):
                        t.visible = 1
                    if SHOWMINIMIZED and self._HIDDEN not in t.state:
                        t.visible = 0
                    if t.visible:
                        visible.append(task)

        # Clear the panel and add the objects
        self.updateBackground(root, win)
        self.clearPanel(0, 0, 0, 0)

        for section in panel["sections"]:
            if panel[section].id == "tasks" and TASKS:
                if not visible:
                    location.incPos(space)
                else:
                    # get the end coordinates where tasks can be drawn
                    final = location.getTaskEndPosition(space)

                    # calculate task text width
                    limit = location.getTaskTextLimit(visible, space)

                    # show all visible tasks, and update task hitbox while doing that
                    for v in range(len(visible)):
                        task = tasks[visible[v]]
                        task.x1 = location.x
                        task.y1 = location.y
                        task.y2 = location.y + I_SIZE
                        if location.getIcon(self.window.id, task, location.x, location.y):
                            location.x += I_SIZE + P_SPACER

                        # draw task text, centered if user wants that
                        text_x = location.x
                        text_width = limit
                        if T_CENTER_TEXT:
                            text_width = ppfontsize(task.name) + 2
                            if text_width < limit:
                                text_x += (limit - text_width) / 2
                            else:
                                text_width = limit
                        self.drawText(task, text_x, location.y, text_width)

                        location.x += limit
                        task.x2 = location.x

                        # update position to next task
                        location.incToNextTask()

                        # lines between tasks in vertical mode isn't so good without spacing
                        if P_LOCATION < 2:
                            location.drawLine(win, self.lgc)

                    # update position to end of tasks part
                    location.x = final[0]
                    location.y = final[1]

                if not panel[section].last:
                    location.drawLine(win, self.lgc)

            elif panel[section].id == "clock":
                clock.x1 = location.x
                clock.y1 = location.y

                location.drawClockDesktopText(self, clock)
                location.incPos(P_SPACER)

                if P_LOCATION < 2:
                    location.x += clock.width
                    clock.x2 = location.x
                else:
                    location.y += I_SIZE
                    clock.x2 = location.width

                clock.y2 = clock.y1 + I_SIZE


                if not clock.last:
                    location.drawLine(win, self.lgc)

            elif panel[section].id == "desktop":
                desktop.x1 = location.x
                desktop.y1 = location.y
                desk = panel[section].names[cdt]
                desk.x1 = desktop.x1
                desk.y1 = desktop.y1

                location.drawClockDesktopText(self, desk)
                location.incPos(P_SPACER)

                if P_LOCATION < 2:
                    location.x += desk.width
                    desktop.x2 = location.x
                else:
                    location.y += I_SIZE
                    desktop.x2 = location.width

                desktop.y2 = desktop.y1 + I_SIZE

                location.incPos(P_SPACER)

                if not desktop.last:
                    location.drawLine(win, self.lgc)

            elif panel[section].id == "tray" and tray:

                count = 1
                for tid in tray.order:
                    t = tray.tasks[tid]
                    t.x = location.x
                    t.y = location.y
                    t.obj.configure(onerror=self.error, x=location.x, y=location.y, width=I_SIZE, height=I_SIZE)
                    t.obj.map(onerror=self.error)
                    location.incToNextTrayIcon(count, len(tray.order))
                    count += 1

                location.incPos(P_SPACER)

                if not tray.last:
                    location.drawLine(win, self.lgc)

            elif panel[section].id == "launcher" and launcher:

                count = 1
                for app in launcher.order:
                    a = launcher.tasks[app]
                    a.x1 = location.x
                    a.y1 = location.y
                    a.x2 = a.x1 + I_SIZE
                    a.y2 = a.y1 + I_SIZE
                    if self.location.getIcon(self.window.id, a, location.x, location.y, 1):
                        location.incToNextTrayIcon(count, len(launcher.order))
                        count += 1

                location.incPos(P_SPACER)

                if not launcher.last:
                    location.drawLine(win, self.lgc)


    #------------------------------------------------------
    def updateTasks(self, dsp, root, win, panel, update=0):
    #------------------------------------------------------
        """ Check the tasklist for additions/deletions/changes """
        cdt   = self.getDesktop()
        tasks = root.get_full_property(self._CLIENT_LIST, Xatom.WINDOW).value
        count = 0

        for task in [t for t in tasks if t not in panel[TASKS].tasks]:
            obj  = dsp.create_resource_object("window", task)
            odt  = self.getDesktop(obj)
            name = self.getName(obj)
            hide = 0

            try:
                if self._SKIP_TASKBAR in obj.get_full_property(self._STATE, Xatom.ATOM).value:
                    hide = 1
            except:
                pass
            try:
                tclass = obj.get_full_property(Xatom.WM_CLASS, Xatom.STRING)

                if tclass is None:
                    tclass = ["",""]
                else:
                    tclass = tclass.value.split("\0")[:2]
                    for t in tclass:
                        if t in HIDE_LIST:
                            hide = 1
            except:
                continue

            if name == "PyPanel":
                hide = 1
                count += 1
                if count == 2:
                    sys.stderr.write("\nPyPanel is already running! Terminating ...\n\n")
                    sys.exit()
            if not hide:
                obj.change_attributes(event_mask=(
                    X.PropertyChangeMask|X.FocusChangeMask|X.StructureNotifyMask))

            t = Obj(id=task, obj=obj, name=name, tclass=tclass, x1=-1, x2=-1, y1=-1, y2=-1, desk=odt, visible=0, hidden=hide)

            panel[TASKS].order.append(task)
            panel[TASKS].tasks[task] = t
            self.setIcon(t)

            if self.setState(t, panel):
                update = 1
            if not update and odt == cdt:
                update = 1

        if update:
            self.updatePanel(root, win, panel)

    #-------------------------------------
    def loop(self, dsp, root, win, panel):
    #-------------------------------------
        """ Event loop - handle events as they occur until we're killed """
        if CLOCK:
            clock = panel[CLOCK]
        if TRAY:
            tray = panel[TRAY]

        tasks = panel[TASKS]
        focus = dsp.get_input_focus().focus

        if hasattr(focus, "id"):
            self.focus = focus.id

        while 1:
            while dsp.pending_events():
                e = dsp.next_event()
                if e.type == X.ButtonRelease:
                    self.buttonRelease(root, panel, e)
                elif e.type == X.DestroyNotify:
                    if self.taskDelete(e.window.id, panel):
                        self.updatePanel(root, win, panel)
                elif e.type == X.PropertyNotify:
                    if e.atom in [self._CURRENT_DESKTOP, self._DESKTOP]:
                        if hasattr(e, "window"):
                            if e.window.id in tasks.tasks:
                                t = tasks.tasks[e.window.id]
                                t.desk = self.getDesktop(t.obj)
                        self.updatePanel(root, win, panel)
                    elif e.atom in [self._DESKTOP_NAMES, self._DESKTOP_COUNT]:
                        self.getDesktopNames()
                        self.updatePanel(root, win, panel)
                    elif e.atom == self._CLIENT_LIST:
                        self.updateTasks(dsp, root, win, panel)
                    elif e.atom == self._RPM:
                        self.updatePanel(root, win, panel)
                    elif e.window.id in tasks.tasks:
                        if e.atom in [self._STATE, self._WMSTATE]:
                            if self.setState(tasks.tasks[e.window.id], panel, win):
                                self.updatePanel(root, win, panel)
                        elif e.atom in [Xatom.WM_NAME, self._NAME]:
                            self.setName(win, tasks.tasks[e.window.id])
                        elif e.atom in [Xatom.WM_HINTS, self._ICON]:
                            t = tasks.tasks[e.window.id]
                            self.setIcon(t)
                            if t.visible:
                                x = t.x1 + P_SPACER
                                y = t.y1
                                width = t.x2 - t.x
                                height = t.y2 - t.y
                                self.clearPanel(x, y, width, height)
                                if self.location.getIcon(self.window.id, t, x, y):
                                    x += I_SIZE+P_SPACER
                                self.drawText(t, x, y, width - P_SPACER)
                elif e.type == X.ConfigureNotify and TRAY:
                    if e.window.id in tray.tasks:
                        task = tray.tasks[e.window.id]
                        task.obj.configure(onerror=self.error, width=task.width, height=task.height)
                elif e.type == X.ClientMessage and TRAY:
                    if e.window == self.selowin:
                        data = e.data[1][1] # opcode
                        task = e.data[1][2] # taskid
                        if e.client_type == self._OPCODE and data == 0:
                            # SYSTEM_TRAY_REQUEST_DOCK opcode = 0
                            obj = dsp.create_resource_object("window", task)
                            obj.reparent(tray.window.id, 0, 0)
                            obj.change_attributes(event_mask=(X.ExposureMask|X.StructureNotifyMask))
                            tray.tasks[task] = Obj(obj=obj, x=0, y=0, width=0, height=I_SIZE)
                            tray.order.append(task)
                            self.updatePanel(root, win, panel)
                elif e.type == X.EnterNotify and e.window.id == win.id:
                        if self.location.expand(self, win):
                            self.updateExpand(root, win, panel)
                            self.hidden = 0
                        elif self.hidden:
                            self.toggleHidden()
                            self.updateTasks(dsp, root, win, panel)
                elif e.type == X.LeaveNotify and e.window.id == win.id:
                        if self.location.shrink(self, win):
                            self.updateExpand(root, win, panel)
                elif e.type == X.FocusIn:
                    prev_focus = self.focus
                    self.focus = e.window.id
                    for wid in (e.window.id, prev_focus):
                        if wid in tasks.tasks:
                            if self.setState(tasks.tasks[wid], panel, win):
                                self.updatePanel(root, win, panel)
                elif e.type == X.Expose and e.count == 0:
                    if e.width == P_THICKNESS:
                        win.change_property(self._DESKTOP, Xatom.CARDINAL, 32, [0xffffffffL])
                        self.sendEvent(win, self._STATE, [1, self._STICKY])
                        self.sendEvent(win, self._STATE, [1, self._SKIP_PAGER])
                        self.sendEvent(win, self._STATE, [1, self._SKIP_TASKBAR])
                        if ABOVE:
                            self.sendEvent(win, self._STATE, [1, self._ABOVE])
                        else:
                            self.sendEvent(win, self._STATE, [1, self._BELOW])
                        self.updateTasks(dsp, root, win, panel, 1)
                    else:
                        self.updatePanel(root, win, panel)

            rs, ws, es = select.select([dsp.display.socket], [], [], CLOCK_DELAY)
            if not rs:
                if AUTOHIDE and not self.hidden:
                    self.toggleHidden()
            if CLOCK:
                now = self.getClockData()
                if clock.name != now:
                    clock.name = now
                    clock.width = ppfontsize(clock.name)
                    self.clearPanel(clock.x1, clock.y1, clock.x2 - clock.x1, clock.y2 - clock.y1)
                    self.location.drawClockDesktopText(self, clock)

#----------------------------------------------------------------------------
#                                  Main
#----------------------------------------------------------------------------
from distutils import sysconfig
from ppmodule import ppinit, ppshade, ppicon, ppfont, ppfontsize, ppclear
from Xlib import X, display, error, Xatom, Xutil
import Xlib.protocol.event
import locale, os, pwd, select, sys, time

# New default config options which may not exist in ~/.pypanelrc if upgrading
# v2.2
HIDDEN_SIZE   = 2
SHOWBORDER    = 0
SHOWMINIMIZED = 0
# v2.3
ABOVE         = 1
LAUNCHER      = 0
LAUNCH_LIST   = []
APPL_I_HEIGHT = 24
APPL_I_WIDTH  = 24
ICON_LIST     = {"default":""}
# v2.4
SHADOWS                = 0
TASK_SHADOW_COLOR      = "0xffffff"
FOCUSED_SHADOW_COLOR   = "0xffffff"
SHADED_SHADOW_COLOR    = "0xffffff"
MINIMIZED_SHADOW_COLOR = "0xffffff"
DESKTOP_SHADOW_COLOR   = "0xffffff"
CLOCK_SHADOW_COLOR     = "0xffffff"
# 130211
T_FILL  = 0
T_WIDTH = 180
# 130521
TIME_BEATS = 0
# 160519
T_FORCE_ASCII = 0
# 160730
I_SIZE = None
P_THICKNESS = None
P_LENGTH = None
BEATS_FORMAT = "@%.2f .beats"
T_CENTER_TEXT = 1
# 160731
P_EXPAND = 50

#-------------------------
if __name__ == "__main__":
#-------------------------
    try:
        src  = None
        dst  = None
        home = pwd.getpwuid(os.getuid())[5]
        if os.access("/etc/pypanelrc", os.F_OK|os.R_OK):
            src = "/etc/pypanelrc"
            execfile(src)
        if not os.access("%s/.pypanelrc" % home, os.F_OK|os.R_OK):
            # Create ~/.pypanelrc from /etc/pypanelrc if it exists else
            # create it from /<pythonlib>/site-packages/pypanel/pypanelrc
            import shutil
            if not src:
                src = "%s/pypanel/pypanelrc" % sysconfig.get_python_lib()
            dst = "%s/.pypanelrc" % home
            shutil.copyfile(src, dst)
        execfile("%s/.pypanelrc" % home)
        del src, dst, home
    except StandardError, e:
        sys.stderr.write("\nFailed to open ~/.pypanelrc -\n\n")
        sys.stderr.write(str(e)+"\n\n")
        sys.exit()

    if I_SIZE == None:
        I_SIZE = I_WIDTH
    if P_THICKNESS == None:
        P_THICKNESS = P_HEIGHT
    if P_LENGTH == None:
        P_LENGTH = P_WIDTH

    # Version check
    main   = 2.4
    config = globals().get("VERSION", None)

    # Set locale to user's default
    locale.setlocale(locale.LC_ALL, "")

    if not config or config != main:
        sys.stderr.write("\npypanelrc version : %s\n" % config)
        sys.stderr.write("pypanel   version : %s\n" % main)
        sys.stderr.write("\nA current pypanelrc example can be found here -\n")
        sys.stderr.write("%s/pypanel/pypanelrc\n\n" % sysconfig.get_python_lib())
    del main, config

    PyPanel(display.Display())
